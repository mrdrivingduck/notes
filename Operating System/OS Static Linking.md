# OS - Static Linking

Created by : Mr Dk.

2020 / 06 / 27 16:28

Nanjing, Jiangsu, China

---

> 本文内容来自于 _程序员的自我修养 - 链接、装载与库，俞甲子 石凡 潘爱民著_。

---

## Two-pass Linking

链接的目标是，将几个目标文件加工后合并为一个目标文件。整个过程将分为两步：

1. 空间和地址分配 - 同时将输入目标文件符号表中的所有符号定义、符号引用收集起来，统一放到一个全局符号表中
2. 符号解析与重定位 - 读取每个目标文件的重定位信息，调整代码中的地址

## 空间与地址分配

空间与地址的含义有两点：

1. 在输出的可执行文件中的空间
2. 被 OS 装载后的虚拟地址空间

链接器会将 **相同性质** 的段合并到一起 - 比如将所有目标文件的 `.text` 合并在一起。而 `.bss` 段在文件中不占用空间，但是在装载后会占用地址空间，所以链接器也会将每个目标文件的 `.bss` 合并并分配空间。

链接后的程序中使用的地址已经是程序在进程中的虚拟地址 (Virtual Memory Address, VMA)。链接前，目标文件中所有段的 VMA 都是 0，即从 0 地址开始分配起始地址，说明虚拟地址空间还没有被分配。在链接后，各目标文件的虚拟地址才被确定下来。在 Linux 下，ELF 文件默认从 `0x08048000` 开始分配地址。

当地址空间分配完毕后，各个段在链接后的虚拟地址已经确定。此时，可以将全局符号表中的符号地址全部更新为分配完毕的虚拟地址 (原先符号表中的地址为本目标文件中的地址)。这一步完成之后，所有符号的地址可以被确定，下一步就要把程序中引用符号的地方替换为符号对应的虚拟地址。

## 符号解析与重定位

在链接之前，已经被编译完毕的目标文件是如何引用外部符号的？编译器会在指令中使用临时的假地址，因为编译器并不知道引用外部函数的真正地址。链接器在完成地址和空间分配之后，就可以对每个需要重定位的指令进行地址修正。

### 重定位表

链接器如何知道哪些指令需要被修正？指令的哪些部分要被修正？怎么修正？这是由 ELF 文件中的 **重定位表 (Relocation Table)** 指示的。在 ELF 文件中，重定位表也是一个段，一个重定位表一般对应于 ELF 中的一个段，比如 `.rel.text` 对应 `.text`。表中记录的每一个需要被重定位的地方被称为 Relocation Entry：

```c
typedef struct
{
  Elf64_Addr	r_offset;		/* Address */
  Elf64_Xword	r_info;			/* Relocation type and symbol index */
} Elf64_Rel;
```

其中，`r_offset` 表示重定位位置的第一个 byte 在段中的偏移量；`r_info` 表示重定位位置的类型，以及符号在符号表中的下标。每种处理器都有不同的重定位结构体，以上是 Intel x86 架构的重定位结构。

每一个重定位结构都是一个对当前目标文件中未定义的符号的引用。链接器会到全局符号表中负责查找符号对应的地址。如果链接正确，应当能够在全局符号表中找到，否则链接器就会报符号未定义错误。

接下来，对指令中的地址修正分为两类：

1. 绝对地址修正 - 将地址修正为符号的实际地址
2. 相对地址修正 - 将地址修正为符号与被修正位置的地址差

---

## 静态库链接

静态库可以看成是一组目标文件的集合，经过压缩打包后形成的文件。其中包含了很多与系统功能相关的函数，对 OS 的 API 进行了封装。在库中，每个系统函数都对应一个目标文件，函数之间还存在依赖关系 - 这是为了防止把一些没有用到的函数也一起链接到输出结果中。链接器会自动寻找所有需要的符号，以及符号所在的目标文件，从库中解压出来，最终链接在一起。

---
