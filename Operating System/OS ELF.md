# OS - ELF

Created by : Mr Dk.

2020 / 06 / 26 0:26

Nanjing, Jiangsu, China

---

> 过去几个月也没少碰 ELF 文件，一些知识总结在了项目文档中。本文内容来自于 _程序员的自我修养 - 链接、装载与库，俞甲子 石凡 潘爱民著_。

---

## About the Format

编译器编译后生成的文件叫做目标文件。从结构上讲，它已经符合可执行文件的格式，只是没有被链接，因此一些符号和地址可能还没有被调整。目前流行的可执行文件格式有 Windows 下的 PE (Portable Executable) 和 Linux 下的 ELF (Executable Linkable Format)，它们都是 COFF (Common File Format) 的变种。目标文件就是 Windows 下的 `.obj` 或 Linux 下的 `.o`，也基本使用了对应的可执行文件格式。另外，动态链接库 (`.dll` / `.so`) 与静态链接库 (`.lib` / `.a`) 也使用相同的格式。ELF 格式的文件分类就有以下几种：

- 可重定位文件 (Relocatable File) - 目标文件
- 可执行文件 (Executable File)
- 共享目标文件 (Shared Object File)
- 核心转储文件 (Core Dump File)

## Sections

目标文件包含了机器代码、数据，另外还有一些符号表、调试信息、字符串等。目标文件将这些信息按不同的属性分段 (section) 存储。比如，指令分为一个段，数据分为一个段。

- `.text` - 代码
- `.data` - 已初始化的全局变量和局部静态变量
- `.bss` - 未初始化的全局变量和局部静态变量 (只是预留位置，在文件中不占据空间)
- `.rodata` - 只读数据，支持 C++ 的 `const` 关键字

分段的原因是，一般来说指令是只读的，数据是可读可写的，OS 可以将这两个区域的虚拟内存分别设置只读权限和可读写权限，防止程序指令被意外修改。另外，当系统中运行程序的多个副本时 (多进程)，指令是相同的，因而可以被共享。目前的 CPU cache 一般也都被设置为数据 cache 和指令 cache 分离。

文件中还有段表 (section table)，其中包含描述每一个段信息的段描述符。编译器、链接器、装载器依靠段表来定位和访问段属性。段描述符记录了除段具体内容以外的所有信息，对于编译器和链接器来说，主要关注段的 **类型** 和 **标志位**：

- 在类型上，代码、数据都属于 `SHT_PROGBITS` (程序段)，另外还有字符串、符号、动态链接等段类型
- 在标志位上，`SHF_WRITE` (可写)，`SHF_ALLOC` (在进程中需要分配空间)，`SHF_EXECINSTR` (进程空间可执行)

### Relocation Table

对于需要重定位的段，ELF 中还有有类似 `.rel.*` 的 **重定位表**。如，`.text` 对应 `.rel.text`。重定位表段的类型为 `SHT_REL`，其中记录了代码段中的重定位信息。

### String Table

ELF 中还有专门用于保存字符串的段，类型为 `SHT_STRTAB`。这样其它的 section 中可以通过引用该段中的下标来引用字符串。比如每个段的名称就被专门保存在一个段中。

---

## Symbol

在链接中，目标文件之间的相互拼合实际上是目标文件之间对函数和变量地址的引用。一个目标文件 **定义** 了变量或函数，另一个目标文件 **引用** 了变量或函数。每个函数和变量都有自己独特的名字，避免链接过程中与其它名称混淆。在链接中，函数和变量统称为 **符号 (symbol)**。

每个目标文件中都有一个符号表，每个符号对应一个符号值。对于变量和函数来说，符号值就是它们的地址。符号表中的符号可能用于：

- 定义在本目标文件内的 **全局符号**，可被其它目标文件引用
- 本目标文件引用的 **全局符号**，而没有被定义在本目标文件 (外部符号)
- 段名
- 局部符号 (只在编译单元内部可见，对链接没有作用)
- 目标文件指令与代码行的对应关系

其中，全局符号是链接过程最关注的部分。ELF 文件中的符号表是一个名为 `.symtab` 的段，是一个由多个符号结构体组成的数组。每个符号结构体记录的信息有，符号名、符号值、符号占据空间大小、符号类型和绑定信息、符号所在段等。

```c
typedef struct
{
  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
  unsigned char	st_info;		/* Symbol type and binding */
  unsigned char st_other;		/* Symbol visibility */
  Elf64_Section	st_shndx;		/* Section index */
  Elf64_Addr	st_value;		/* Symbol value */
  Elf64_Xword	st_size;		/* Symbol size */
} Elf64_Sym;
```

通过符号类型和绑定信息，可以确定符号是全局符号还是局部符号，符号是一个函数还是一个变量：

- `STB_LOCAL`
- `STB_GLOBAL`
- `STB_WEAK`

通过符号所在段，可以判断符号是否定义在当前目标文件中：

- Section 下标
- `SHN_ABS` - 绝对值，如文件名
- `SHN_COMMON` - 未初始化的全局符号定义
- `SHN_UNDEF` - 符号在本目标文件中被引用，但定义在其它目标文件中

另外，在链接器的链接脚本中还有一些特殊符号。程序并没有定义它们，但是可以直接声明它们并使用：

- `__executable_start` - 程序起始地址
- `__etext` - 代码段结束地址
- `_edata` - 数据段结束地址
- `_end` - 程序结束地址

## 符号修饰与函数签名

如果直接用函数名作为符号名，意味着要链接该库的目标文件中不能使用与该库中函数和变量相同的符号名，否则就会出现符号名冲突。C++ 在设计时就考虑到了这个问题，通过 name space 解决这个问题。

C++ 编译器在编译源代码时，会对函数和变量名进行 **修饰**，并作为符号名。该符号名中包含：

- 函数名
- 函数参数类型
- 所在类与 name space
- ...

不同的编译器的修饰方式各有不同。

---

## Debug Information

在编译时多加一个选项，可以在目标文件中生成很多个用于调试的段。这些信息可能会占用很大的空间，甚至比程序本身的代码和数据还大好几倍。当程序发布前，Linux 下可以使用 `strip` 去掉 ELF 文件中的调试信息。

---
